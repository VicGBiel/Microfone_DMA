.program i2s_mic
.side_set 2

; Bit 0 = SCK, Bit 1 = WS

public entry_point:
    set x, 14             side 0b00   

left_channel:
    ; 1. Atraso de 1 bit
    nop                   side 0b01   
    nop                   side 0b00   
    
    ; 2. Ler o MSB 
    in pins, 1            side 0b01   
    
    ; 3. Ler os próximos 23 bits 
    set x, 22             side 0b00   ; Loop de 22 (+1) = 23
loop_bits_left:
    in pins, 1            side 0b01   
    jmp x-- loop_bits_left side 0b00  

    ; 4. Descartar os 8 bits restantes 
    set x, 6              side 0b00   ; 32 - 1 - 24 = 7 clocks restantes
discard_left:
    nop                   side 0b01   
    jmp x-- discard_left  side 0b00   
    
    ; Transição para canal direito
    set x, 14             side 0b10   

right_channel:
    ; Ignora Canal Direito 
    nop                   side 0b11   
    nop                   side 0b10   
    
    set y, 30             side 0b10
discard_right:
    nop                   side 0b11   
    jmp y-- discard_right side 0b10   

    set x, 14             side 0b00

% c-sdk {
static inline void i2s_mic_program_init(PIO pio, uint sm, uint offset, uint data_pin, uint clock_pin_base) {
    pio_sm_config c = i2s_mic_program_get_default_config(offset);
    sm_config_set_in_pins(&c, data_pin);
    sm_config_set_sideset_pins(&c, clock_pin_base);
    pio_gpio_init(pio, data_pin);
    pio_gpio_init(pio, clock_pin_base);
    pio_gpio_init(pio, clock_pin_base + 1);
    pio_sm_set_consecutive_pindirs(pio, sm, data_pin, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, clock_pin_base, 2, true);
    
    // Shift de 24 bits
    // Configuramos para 32 bits, onde os 8 bits superiores serão zero (padding automático do PIO).
    sm_config_set_in_shift(&c, false, true, 24); 
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
    pio_sm_init(pio, sm, offset, &c);
}
%}